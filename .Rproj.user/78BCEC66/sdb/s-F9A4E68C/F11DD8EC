{
    "collab_server" : "",
    "contents" : "%\\VignetteIndexEntry{Partially Observed Boolean Dynamical Systems}\n\\documentclass[a4paper]{article}\n\n\\SweaveOpts{keep.source=TRUE}\n\n\\title{BoolFilter Package Vignette}\n\\author{Levi D. McClenny, Mahdi Imani, Ulisses Braga-Neto\\\\\n        Dept. of Electrical and Computer Engineering\\\\\n  \tTexas A\\&M University - College Station, TX\\\\\n\t\t\\texttt{levimcclenny@tamu.edu, m.imani88@tamu.edu, ulisses@tamu.edu}}  %\\texttt formats the text to a typewriter style font\n\\date{\\today}  %\\today is replaced with the current date\n\n\n\\usepackage{fancyhdr}\n\n\n\\usepackage{a4wide}\n\n\\usepackage{graphicx}\n%\\usepackage{amsmath}\n\\usepackage{hyperref}\n\\usepackage{amsmath,amssymb,amsthm,mathrsfs}\n\\usepackage{cite}\n\\usepackage{graphicx}\n%\\usepackage{fullpage}\n\\usepackage{amsmath}\n\\usepackage{pbox}\n\\usepackage{commath}\n\\usepackage{booktabs,caption}\n\\usepackage{multirow}\n%\\usepackage{kbordermatrix}\n%\\usepackage{fancyhdr}\n\\usepackage{lastpage}\n\\usepackage{float}\n%\\usepackage{pgfplots}\n\n\\usepackage{listings}\n\\lstset{breaklines=true, breakautoindent=false, breakindent=0pt, columns=fullflexible,keepspaces=true, basicstyle=\\small\\ttfamily}\n\n\\setlength{\\parindent}{0em}\n\\setlength{\\parskip}{0.2em}\n\n\\newcommand{\\sbs}{\\substack}\n\\newcommand{\\bc}{\\begin{center}}\n\\newcommand{\\ec}{\\end{center}}\n\\newcommand{\\bi}{\\begin{itemize}}\n\\newcommand{\\ei}{\\end{itemize}}\n\\newcommand{\\ba}{\\begin{array}}\n\\newcommand{\\ea}{\\end{array}}\n\\newcommand{\\bal}{\\begin{aligned}}\n\\newcommand{\\eal}{\\end{aligned}}\n\\newcommand{\\beq}{\\begin{equation}}\n\\newcommand{\\eeq}{\\end{equation}}\n\\newcommand{\\bcs}{\\begin{cases}}\n\\newcommand{\\ecs}{\\end{cases}}\n\\newcommand{\\beqa}{\\begin{eqnarray}}\n\\newcommand{\\eeqa}{\\end{eqnarray}}\n\\newcommand{\\nn}{\\nonumber}\n\\newtheorem{thm}{Theorem}\n\\newcommand{\\argmax}{\\operatornamewithlimits{argmax}}\n\n\\theoremstyle{plain}\n\\newtheorem{theorem}{Theorem}\n\\newtheorem{lemma}[theorem]{Lemma}\n\\newtheorem{proposition}[theorem]{Proposition}\n\\theoremstyle{definition}\n\\newtheorem{definition}[theorem]{Definition}\n\\newtheorem{problem}[theorem]{Problem}\n\\theoremstyle{remark}\n\\newtheorem{remark}[theorem]{Remark}\n\n\\def\\prf{\\noindent{\\sc Proof}.\\ }\n\\def\\qed{Q.E.D. \\vspace{1ex}}\n\\newcommand{\\bprop}{\\begin{proposition}}                                                                    \n\\newcommand{\\eprop}{\\end{proposition}}                                                                      \n\n\\def\\bibdir{/Users/ulisses/doc/bib}\n\n% Definitions\n\\def\\rt{\\rightarrow}\n\\def\\Xk{{\\bf X}_k}\n\\def\\Zk{{\\bf Z}_k}\n\\def\\xk{{\\bf x}_k}\n\\def\\w{{\\bf w}}\n\\def\\M{{\\bf M}}\n\\def\\N{{\\bf \\textit{N}}}\n\\def\\Tky{{T}_k{\\bf (y)}}\n\\def\\Yk{{\\bf Y}_k}\n\\def\\f{{\\bf{f}}}\n\\def\\v{{\\bf{v}}}\n%\\def\\uk{{\\bf u}_k}\n\\def\\uk1{{\\bf{u}}_{k-1}}\n\\def\\xone{{\\bf{x}}_{1}}\n\\def\\xzero{{\\bf{x}}_{0}}\n\\def\\Xkm{{\\bf X}_{k-1}}\n\\def\\Zkm{{\\bf Z}_{k-1}}\n\\def\\xkm{{\\bf x}_{k-1}}\n\\def\\h{{\\bf{h}}}\n\\def\\nk{{\\bf n}_k}\n\\def\\nkp{{\\bf n}_{k+1}}\n\\def\\vk{{\\bf v}_k}\n\\def\\uk{{\\bf u}_k}\n\\def\\rk{{\\bf r}_k}\n\\def\\nl{{\\bf n}_{l}}\n\\def\\vl{{\\bf v}_l}\n\\def\\xk{{\\bf x}_k}\n\\def\\yk{{\\bf y}_k}\n\\def\\hXk{{\\bf \\hat{X}}_k}\n\\def\\hXkp{{\\bf \\hat{X}}_{k+1}}\n\\def\\Xkp{{\\bf X}_{k+1}}\n\\def\\hWk{{\\bf \\hat{W}}_k}\n\\def\\hWkm{{\\bf \\hat{W}}_{k-1}}\n\\def\\hXkm{{\\bf \\hat{X}}_{k-1}}\n\\def\\hfk{{\\bf \\hat{f}}_k}\n\\def\\X{{\\bf X}}\n\\def\\Y{{\\bf Y}}\n\\def\\Z{{\\bf Z}}\n\\def\\Yon{{\\bf Y}_1}\n\\def\\etk{{\\mbox{\\boldmath $\\eta$}_k}}\n\\def\\mse{{\\rm MSE}}\n\\def\\msec{{\\rm MSE}}\n\\def\\x{{\\bf x}}\n\\def\\y{{\\bf y}}\n\\def\\yon{{\\bf y}_1}\n\\def\\Pik{{\\bf \\Pi}_{k|k}}\n\\def\\Pikm{{\\bf \\Pi}_{k|k-1}}\n\\def\\Pikmm{{\\bf \\Pi}_{k-1|k-1}}\n\\def\\Ykm{{\\bf Y}_{k-1}}\n\\def\\Piz{{\\bf \\Pi}_{0|0}}\n\\def\\PI{{\\bf \\Pi}}\n\\def\\Xz{{\\bf X}_0}\n\\def\\xz{{\\bf x}_0}\n\\def\\Wz{{\\bf W}_0}\n\\def\\Mk{{M_k}}\n\\def\\Tk{{T_k}}\n\\def\\Mon{{M_1}}\n\\def\\Ton{{T_1}}\n\\def\\Ck{{C_k}}\n\\def\\btk{{\\mbox{\\boldmath $\\beta$}_k}}\n\\def\\bt{{\\mbox{\\boldmath $\\beta$}}}\n\\def\\bb{{\\mbox{\\boldmath $b$}}}\n\\def\\atk{{\\mbox{\\boldmath $\\alpha$}_k}}\n\\def\\alk{{\\mbox{\\boldmath $\\alpha$}_k}}\n\\def\\YN{{\\bf Y}_N}\n\\def\\Wk{{\\bf W}_k}\n\\def\\Wl{{\\bf W}_l}\n\\def\\Wkm{{\\bf W}_{k-1}}\n\\def\\etak{\\eta_k}\n\\def\\Sb{\\bf S}\n\\def\\obsplus{\\diamondplus}\n\\def\\vk{{\\bf v}_k}\n\\def\\vkm{{\\bf v}_{k-1}}\n\\newcommand{\\argmin}{\\operatornamewithlimits{argmin}}\n\n\n\\widowpenalty=10000\n\\clubpenalty=10000\n\n\\hyphenation{me-thods pro-per-ties re-pre-sen-ta-tion}\n\n\n\n\n\\pagestyle{fancy}\n\\rhead{Partially-Observed Boolean Dynamical Systems}\n\\rfoot{R Package: BoolFilter}\n\n\n\\begin{document}\n\\SweaveOpts{concordance=TRUE}\n\\maketitle\n\\tableofcontents\n\\clearpage\n\\section{Introduction}\n\n\n\\indent The \\texttt{BoolFilter} package provides tools for state estimation and inference of partially-observed Boolean dynamical systems. \nThis package contains functions for simulating data, obtaining the optimal estimator in the presence of various observation noise models\\cite{Brag:11}, applying the optimal MMSE filter and smoother\\cite{ImanBrag:15b}, particle filter implementation of optimal filter~\\cite{braga2013particle}, as well \nas means of parameter estimation and network inference\\cite{ImanBrag:15a}.\n\\\\[1em]\n\\indent \\texttt{BoolFilter} was created explicitly to handle the latest tools developed for signal model of partially-observed Boolean dynamical system (POBDS).\nThis signal model, proposed in \\cite{Brag:11}, was introduced to model dynamical systems containing Boolean variables observed indirectly through a noisy measurement process. This observation noise could be a result of instrumentation, incorrect thresholding, etc. \n\\\\[1em]\nA characteristic signal model for the partially-observed Boolean dynamical system can be represented by the equations\\cite{Brag:11}\\cite{ImanBrag:16b}\n\n\\beq\n\\bal\n  \\Xk &\\,=\\, \\f\\left(\\Xkm\\right) \\:\\:\\oplus\\:\\: \\nk\\quad \\textrm{(state model)} \\\\[1ex]\n  \\Yk &\\,=\\, \\h\\left(\\Xk,\\vk\\right) \\quad \\textrm{(observation model)}\n\\label{eq-sgnmodel}\n\\eal\n\\eeq\n\nfor $k=1,2,\\ldots$. Here, $\\nk \\in \\{0,1\\}^d$ is Boolean transition noise,\n``$\\oplus$'' indicates component-wise\nmodulo-2 addition, and $\\f: \\{0,1\\}^{d} \\longrightarrow \\{0,1\\}^d$ is the network function,\nwhereas $\\h$ is a\ngeneral function mapping the current state and observation noise $\\vk$\ninto the measurement space. The\nnoise processes $\\{\\nk, \\vk; k=1,2,\\ldots\\}$ are assumed to be\n``white'' in the sense that the noises at distinct time points are\nuncorrelated random variables.  \nIt is also assumed that the\nnoise processes are uncorrelated with each other and with the initial\n state $\\Xz$.\\\\[1em]\nSeveral tools for POBDSs have been developed in recent years such as the optimal filter and smoother based on the minimum mean square error (MMSE) criterion, called the Boolean Kalman Filter (BKF)~\\cite{Brag:11} and Boolean Kalman Smoother (BKS)~\\cite{ImanBrag:15b}, respectively. In addition, schemes for simultaneous state and parameter estimation, optimal filter in the case of correlated noise, network inference, fault detection, and control for POBDS were introduced in~\\cite{ImanBrag:16b}\\cite{LeviBrag:17}\\cite{ImanBrag:15a}\\cite{BahaBrag:15}\\cite{ImanBrag:16a}\\cite{ImanBrag:16c}.\n\\\\[1em]\n\\texttt{BoolFilter} package is developed to make the latest developed tools for the POBDS accessible. First, the package can be installed from CRAN with the command \n \n\\begin{Sinput}\n> install.packages('BoolFilter')\n\\end{Sinput}\n\nOnce the package and its dependencies are fully installed, the package can be loaded into the workspace with the command \n\n<<>>=\nlibrary('BoolFilter')\n@\n\\section{Constructing a Boolean Network}\n\\textit{BoolFilter} relies on the package \\textit{BoolNet} for describing Boolean Networks as input for its functions. This is done with a specific means of inputting a target gene, followed by its update rule\\cite{mussel2015boolnet}. In order to create a Boolean Network, a text file must be created in the users current working directory with the transition rules in a specific format. For instance, the p53-MDM2 gene regulatory network is presented in Figure 1. The network contains 4 genes (ATM, p53, Wip1, Mdm2) and 1 input dna-dsb, which denotes the presence or absence of DNA double strand breaks.  This netwrok is shown below in figure 1:\n\\pagebreak\n\\begin{figure}[h]\n\\hfill\n\\begin{center}\n\\begin{minipage}{0.35\\textwidth}\n\\includegraphics[width=1\\textwidth]{Figures/p53.PNG}\n\\caption{p53-mdm2 Network}\n\\label{p53-mdm2 Network}\n\\end{minipage}\n\\end{center}\n\\end{figure}\n\nOne would create the network in a text file (named 'p53.txt', for instance, saved to the working directory) as follows:\n\\begin{verbatim}\ntargets, factors\nATM, (! Wip1 & 1)\np53, (ATM & ! Wip1 & ! Mdm2)\nWip1, p53\nMdm2, (!ATM & (p53 | Wip1)) | ( p53 & Wip1 )\n\\end{verbatim}\n\nDNA\\textunderscore dsb is an input to ATM. In the above Boolean network, DNA\\textunderscore dsb is \\textit{ON}. In order to toggle the input to \\textit{OFF}, the first line would need to be changed to \n\n\\begin{verbatim}\nATM, (! Wip1 & 0)\n\\end{verbatim}\n\nAfterward, the network can be created into a Boolean Network class by utilizing functions in the \\textit{BoolNet} package.\n<<eval = FALSE>>=\np53net <- loadNetwork('p53.txt')\n@\nAgain, this function is a part of \\textit{BoolNet}, and creates an object of the type that \\textit{BoolFilter} requires for its functionality. This allows for user specification of the genetic regulatory network. \n\nFor simplicity, both p53 networks come included in the \\textit{BoolFilter} package and can be loaded into the workspace using the command\n\n<<eval = FALSE>>=\ndata(p53net_DNAdsb1) #DNA_dsb is ON\ndata(p53net_DNAdsb0) #DNA_dsb is OFF\n@\nwhere ``p53-dnadsb0\" and ``p53-dnadsb1\" are referring to the p53-Mdm2 negative feedback loop regulatory network with external input 0 and 1 respectively.\n\nIn addition ``cellcycle\" and ``melanoma\" Boolean networks are available predefined in database of BoolNet and BoolFilter respectively. \n\nBoolNet also contains functions that allow for the reconstruction of Boolean networks from time series data, generating random networks with various connectivity parameters, or loading networks from SMBL or BioTapestry. More information on the various means of generating Boolean Networks with the BoolNet package can be found in the BoolNet Vignette at \n\\url{https://cran.r-project.org/web/packages/BoolNet/vignettes/BoolNet_package_vignette.pdf}.\n\n\\section{Data Generation}\n\nNetwork simulation takes a manually defined network and steps through the update rules, generating a time series of the genetic expression data of user-specified length. Process noise is assumed in the data generation, where the magnitude is a user defined parameter. For the data generation in \\textit{BoolFilter}, we only considere i.i.d Bernoulli process noise. Two sets of state and measurement trajectories are created by BoolFilter.  \n\\\\[1em]\nTime series expression data can be generated using different observation models. This is useful in the sense that multiple observation noise models can potentially be found when analyzing genetic expression data. There exists a single parameter by which all the parameters for a given observation model can be input, called \\textit{obsModel}. The order in which the parameters of observation models are input to the \\textit{obsModel} parameter is outlined in the following sections. \n\\\\[1em]\nRegardless of the observation model chosen to generate the data, the \\textit{simulateNetwork} fuction will output a list consisting of the simulated state and measurement trajectories (called \\textit{originalState} and \\textit{observation}). \n\n\\subsection{Bernoulli Observation Noise}\n\nThe first case will be Bernoulli observation noise. The intensity of Bernoulli observation noise is defined by parameter q (while p was the intensity of state transition process). The larger the noise parameter, the more noisy the measurements. Only one parameter value is required for Bernoulli observation noise, and \\textit{BoolFilter} will throw an error if more than one parameter is input to a Bernoulli observation model. The following command creates state and observation trajectory with the length of n.data = 100, and intensity of Bernoulli state and process noise p = 0.05 and q = 0.02 respectively.\n\n<<eval = FALSE>>=\ndata <- simulateNetwork(p53net_DNAdsb1, n.data = 100, p = .02,\n                      obsModel = list(type = 'Bernoulli', \n                                      q = 0.05))\n@\n\n<<eval = FALSE>>=\n#View both datasets overlayed\nplotTrajectory(data$X, \n               labels = p53net_DNAdsb1$genes, \n               dataset2 = data$Y, \n               compare = TRUE)\n@\n\n\\subsection{Gaussian Observation Noise}\n\nBoolFilter is capable of generating data with Gaussian noise as well. In the event the user wants to create a Gaussian observation noise process, the parameters to the \\textit{obsModel} parameter vector will be input in the following order:\n\n\\begin{verbatim}\nmu0\nsigma0\nmu1\nsigma1\n\\end{verbatim}\n\n\nThis model assumes that the Boolean states $\\x = 0$ and $\\x = 1$ are observed through Gaussian distributions $\\xzero \\sim \\N$\\textit{(mu0, sigma0)} and $\\xone \\sim \\N$\\textit{(mu1, sigma1)}, respectively, where {(mu0, sigma0)} and {(mu1, sigma1)} are pairs of the mean and standard deviation of the activated and inactivated conditions, respectively.\n\n\n<<eval = FALSE>>=\ndata <- simulateNetwork(p53net_DNAdsb1, n.data = 100, p = 0.02,\n                      obsModel = list(type = 'Gaussian',\n                                      model = c(mu0 = 1, \n                                             sigma0 = 2, \n                                                mu1 = 5, \n                                            sigma1 = 2)))\n@\n\nThis will generate a time series expression dataset with continuous entries,  in which the active and inactive genes are observed through $\\xzero \\sim \\N$\\textit{(1, 2)} and $\\xone \\sim \\N$\\textit{(5, 2)},\n\n\\subsection{Poisson Observation Noise}\n\n\\textit{BoolFilter} comes with a built-in Poisson observation model for modeling RNA sequencing data. Again, similar to the Gaussian observation model, the input parameters of obsModel in Poisson model are as follows:\n\n\\begin{verbatim}\ns\nmu\ndelta\n\\end{verbatim}\n\nwhere \\textit{s} is the sequencing depth, \\textit{mu} is the baseline expression in inactivated state, and \\textit{delta} is the differential expression.\n\\\\[1em]\nThe \\textit{delta} is a vector of the same magnitude as the number of Boolean variables where $delta_j$ denotes the effect of going from inactivated to activated state for $j$-th variable. In addition, \\textit{mu} is a scaler usually between 0 and 1 characterizing the baseline level of expression, and sequencing depth \\textit{s} is an instrument-dependent parameter. See \\cite{ImanBrag:15b} and \\cite{BahaBrag:15}, for more information about the range of different parameters.\n\n\n<<eval = FALSE>>=\nobsModel <- list(type = 'Poisson', s = 10.75, mu = 0.01, delta = c(2, 2, 2, 2))\n\ndata <- simulateNetwork(p53net_DNAdsb1, n.data = 100, p = 0.02, obsModel)\n@\n\n\n\n\\subsection{Negative-Binomial Observation Noise}\n\nAn additional observation model that can be used to model RNA-seq data is the Negative Binomial model. This model allows for the mean and variance to differ, unlike the Poisson distribution outlined in section 3.3. Similar to the Poisson model, the \\textit{obsModel} parameter must be a list, however it adds another extra dispersion parameter vector referred to as \\textit{phi}. The parameters should be input in the following order to obsModel:\n\n\\begin{verbatim}\ns\nmu\ndelta\nphi\n\\end{verbatim}\n\nWhere \\textit{s} is the sequencing depth, \\textit{mu} is the baseline expression in inactivated state, and \\textit{delta} is the differential expression, and \\textit{phi} is the inverse dispersion.\n\nBoth \\textit{delta} and \\textit{phi} must be vectors of the same magnitude as the number of Boolean variables. This allows you to specify the observation model for each gene specifically, if so desired~\\cite{ImanBrag:16b}. \n\\\\[1em]\nChanging the \\textit{type} variable to `NB' will cause the \\textit{simulateNetwork} function to generate data from the negative binomial distribution as shown below: \n\n<<eval = FALSE>>=\nobsModel <- list(type = 'NB', \n                    s = 10.875, \n                    mu = 0.01, \n                 delta = c(3, 3, 3, 3), \n                   phi = c(2, 2, 2, 2))\n\ndata <- simulateNetwork(p53net_DNAdsb1, n.data = 100, p = 0.02, obsModel)\n@\nData can be viewed in the following fashion, if desired:\n<<eval = FALSE>>=\n#display data without observation noise\nplotTrajectory(data$X, labels = p53net_DNAdsb1$genes)\n@\n\n\n\\section{State Estimation of Partially-Observed Boolean Dynamical Systems}\n\n\n\\subsection{Boolean Kalman Filtering}\n\nThe Boolean Kalman Filtering algorithm is the optimal minimum mean-squared error (MMSE) estimator of a Partially-Observed Boolean Dynamical System\\cite{Brag:11},\\cite{ImanBrag:16b}. This algorithm estimates the state of the system recursively as new measurement arrives.\n\\\\[1em]\nData from various sources can be fed into the BKF algorithm. Potential sources include RNA-seq, as well as user generated data outlined in section 3. The Boolean Kalman Filter implementation present in \\textit{BoolFilter} is capable of handling all the observation noise discussed in section 3 regarding simulation - Bernoulli, Gaussian, Poisson, and Negative Binomial. The input to the BKF is handled in much the same way as the \\textit{simulateNetwork} function, and assumes the user knows the distribution and parameters for the observation model.\n\\\\[1em]\nUse is as follows:\n<<eval = FALSE>>=\n#simulate bernoulli noise on p53 network\ndata <- simulateNetwork(p53net_DNAdsb1, n.data = 100, p = .02,\n                      obsModel = list(type = 'Bernoulli', \n                                      q = 0.02))\n@\nFor this example, the p53 network was used for simplicity. Any network can be used, be it user specified, reconstructed, etc. \n<<eval = FALSE>>=\n#run BKF algorithm on simulated data\nResults <- BKF(data$Y, p53net_DNAdsb1, p=0.02,\n                       obsModel = list(type = 'Bernoulli', \n                                      q = 0.02))\n@\nThe output, in this case labeled 'Results,' contains the estimated state, unnormalized posterior probability, as well as the conditional MSE at each time point. After performing the BKF and estimating states, the differences between the estimate and the original state trajectory can be viewed by plotting the trajectories of the genes using \\textit{plotTrajectory} and comparing them as: \n\n<<eval = FALSE>>=\n#plot the original and estimated trajectories on top of each other.\nplotTrajectory(data$X, \n               labels = p53net_DNAdsb1$genes, \n               dataset2 = Results$Xhat, \n               compare = TRUE)\n@\n\n\n\\subsection{Boolean Kalman Smoother}\nIn cases when the measurements are available offline, the optimal MMSE estimator of state is called Boolean Kalman Smoother\\cite{ImanBrag:15b}. The method contains forward-backward process and can only be implemented on a batch data set. \n\\\\[1em]\nThe implementation is the same as the Boolean Kalman Filter:\n\n<<eval = FALSE>>=\ndata <- simulateNetwork(p53net_DNAdsb1, n.data = 100, p = 0.02,\n                      obsModel = list(type = 'Bernoulli',\n                                         q = 0.05))\n\nResults <- BKS(data$Y, p53net_DNAdsb1, p = 0.02,\n                      obsModel = list(type = 'Bernoulli',\n                                         q = 0.05))\n@\n\nIt is again worth noting that the Boolean Kalman Filter algorithm is the optimal estimator for on-line process, whereas the Boolean Kalman Smoother is the optimal estimator for a given batch available data. \n\n\\subsection{Particle Filter Implementation of BKF}\nThe Boolean Kalman Filter is the optimal MMSE estimator of a POBDS~\\cite{Brag:11}. However, the computation of optimal filter becomes impractical for a large POBDS. This opens the floor for an approximation of the optimal estimator. In order to approximate a BKF, we implement a SIR-BKF  approach, outlined in \\cite{braga2013particle}. \n\\\\[1em]\nThis approximation approach allows us to handle the issue of high dimensional networks in which the BKF approach can prove inefficient in the category of computational intensity. One such network is the 10-gene mammalian cell cycle network outlined in \\cite{faure2006dynamical}\n\\\\[1em]\nUse of the SIR-BKF algorithm is outlined below, applied to the 10-gene Mammalian Cell Cycle network. First data is generated using the \\textit{simulateNetwork()} function described in section 2:\n\n<<eval = FALSE>>=\ndata(cellcycle)\n\ndata <- simulateNetwork(cellcycle, n.data = 100, p = 0.02,\n                      obsModel = list(type = 'Gaussian',\n                                      model = c(mu0 = 1, \n                                             sigma0 = 2, \n                                                mu1 = 5, \n                                             sigma1 = 2)))\n@\n\nThen we apply the Particle Filter algorithm to obtain an approximation of the state variables through the observation noise:\n\n<<eval = FALSE>>=\nResults <- SIR_BKF(data$Y, N = 1000, alpha = 0.9, cellcycle, p = 0.02, \n                         obsModel = list(type = 'Gaussian',\n                                      model = c(mu0 = 1, \n                                             sigma0 = 2, \n                                                mu1 = 5, \n                                             sigma1 = 2)))\n@\n\nThe output 'Results' contains the estimated state and the conditional MSE at each time point. To compare the original and estimated state trajectories, one can use the following command:\n\n<<eval = FALSE>>=\n#compare the estimated and original state trajectories for selected Boolean variables\nVarPlot=c(1,2,5,7)\nplotTrajectory(data$X[VarPlot,], \n               labels = cellcycle$genes[VarPlot], \n               dataset2 = Results$Xhat[VarPlot,], \n               compare = TRUE)\n@\n\nIn the above code, the index \\textit{c(1,4,5,7)} specifies the indices of Boolean variables to be plotted.\n\n\\section{Multiple Model Adaptive Estimation}\n\nSuppose that the nonlinear signal model is\nincompletely specified. For example, the relationship between Boolean variables may be only partially known, or the statistics of the noise\nprocesses may need to be estimated. We assume that the missing\ninformation can be coded into a finite-dimensional vector parameter $\\Theta=\\{\\theta_1,...,\\theta_M\\}$. % where $\\Theta$ is the parameter space. \nAssuming $P(\\theta_i)$, for $i=1,...,M$, is the prior knowledge of $i$th model, the model selection is achieved by running a bank of BKFs running in parallel, one for\neach candidate model. Setting initial probability of models as their prior ($p_0^i=P(\\theta_i), \\,i=1,...,M$), when measurement at time step $k$ appears, \nthe probability of each model is updated recursively as follows:\n\\beq\np_k^i\\,=\\,\\frac{||\\bt_k^i||_1\\,p_{k-1}^i}{\\sum_{j=1}^M ||\\bt_k^j||_1\\,p_{k-1}^j}\n\\eeq\nwhere $\\bt_k^i$ denotes the unnormalized PDV at time $k$, computed at the update step of the BKF for model $\\theta_i$. \n\nThe process continues for different measurement recursively till the maximum\nprobability exceed a given threshold near $1$ ($\\max_{i=1,...,M} p_k^i > t_s$). This leads to the following selected model:\n\\beq\n\\theta^* = \\argmax_{i=1,...,M} p_k^i\n\\eeq\nFor more information about this method, refer to~\\cite{ImanBrag:15a}.\n\\\\[1em]\nTwo sources of unknown models can be modeled for implementation purposes:\n\\begin{enumerate}\n\\item Unknown network: User can define multiple networks as a possible network model to the system. \n\\item Unknown process noise: Different possible intensities of Bernoulli process noise can be entered (as a vector) to the algorithm.\n\\end{enumerate}\nThe main algorithm is implemented as follows:\n<<eval = FALSE>>=\n#load potential networks\ndata(p53net_DNAdsb0)\ndata(p53net_DNAdsb1)\n\nnet1 <- p53net_DNAdsb0\nnet2 <- p53net_DNAdsb1\n@\n\nOnce the networks have been identified, one can be simulated as follows:\n<<eval = FALSE>>=\n#define observation model\nobservation = list(type = 'NB', \n                      s = 10.875, \n                     mu = 0.01, \n                  delta = c(2, 2, 2, 2), \n                    phi = c(3, 3, 3, 3))\n\n#simulate data using one of the networks and a given 'p'\ndata <- simulateNetwork(net1, n.data = 100, p = 0.02, obsModel = observation)\n@\nThe final step will be to call the MMAE function.\n<<eval=FALSE>>=\n#run MMAE to determine model selection and parameter estimation\nMMAE(data$Y, net = c(\"net1\",\"net2\"), p = c(0.02,0.1,0.15), threshold = 0.8, \n                                                    Prior = NA,\n                                                    obsModel = observation)\n@\n\nNote that if the network or process noise intensity is known, one can only input them as their are to the algorithm. In addition, when the prior is not input to this function, uniform prior is considered for all models. \n\\clearpage\n\\bibliographystyle{plain}\n\\bibliography{references}\n\n\n\\end{document}\n",
    "created" : 1482651087135.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2372813670",
    "id" : "F11DD8EC",
    "lastKnownWriteTime" : 1483936791,
    "last_content_update" : 1483936791,
    "path" : "~/Dropbox/BoolFilter/vignettes/BoolFilter.Rnw",
    "project_path" : "vignettes/BoolFilter.Rnw",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "sweave"
}